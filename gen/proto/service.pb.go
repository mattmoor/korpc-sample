// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

package mattmoor

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Request struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{0}
}

func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return xxx_messageInfo_Request.Size(m)
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type Response struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{1}
}

func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*Request)(nil), "mattmoor.Request")
	proto.RegisterType((*Response)(nil), "mattmoor.Response")
}

func init() { proto.RegisterFile("service.proto", fileDescriptor_a0b84a42fa06f626) }

var fileDescriptor_a0b84a42fa06f626 = []byte{
	// 182 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x2d, 0x4e, 0x2d, 0x2a,
	0xcb, 0x4c, 0x4e, 0xd5, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0xc8, 0x4d, 0x2c, 0x29, 0xc9,
	0xcd, 0xcf, 0x2f, 0x52, 0x92, 0xe6, 0x62, 0x0f, 0x4a, 0x2d, 0x2c, 0x4d, 0x2d, 0x2e, 0x11, 0x12,
	0xe0, 0x62, 0xce, 0x2d, 0x4e, 0x97, 0x60, 0x54, 0x60, 0xd4, 0xe0, 0x0c, 0x02, 0x31, 0x95, 0x64,
	0xb8, 0x38, 0x82, 0x52, 0x8b, 0x0b, 0xf2, 0xf3, 0x8a, 0x53, 0x31, 0x65, 0x8d, 0xcc, 0xb9, 0x98,
	0xfd, 0xf3, 0x52, 0x85, 0x0c, 0xb8, 0x58, 0x7d, 0x13, 0xd3, 0x33, 0x93, 0x85, 0x04, 0xf5, 0x60,
	0xa6, 0xea, 0x41, 0x8d, 0x94, 0x12, 0x42, 0x16, 0x82, 0x18, 0xa4, 0xc4, 0x60, 0x94, 0xce, 0xc5,
	0x1c, 0x52, 0x9e, 0x2f, 0xa4, 0xcf, 0xc5, 0xe2, 0x94, 0x53, 0x5a, 0x44, 0xb4, 0x3e, 0x88, 0x86,
	0xc4, 0x0c, 0xe2, 0x2d, 0x9a, 0xce, 0xc8, 0xc5, 0x1a, 0x92, 0x51, 0x94, 0x9a, 0x2a, 0xa4, 0xc7,
	0xc5, 0xec, 0x96, 0x9f, 0x4f, 0xbc, 0x55, 0x7a, 0x5c, 0xcc, 0x4e, 0x89, 0x45, 0x24, 0xaa, 0xaf,
	0x22, 0x5a, 0x7d, 0x12, 0x1b, 0x38, 0x1e, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4c, 0x08,
	0xeb, 0xd9, 0x98, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OneClient is the client API for One service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OneClient interface {
	Magic(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type oneClient struct {
	cc *grpc.ClientConn
}

func NewOneClient(cc *grpc.ClientConn) OneClient {
	return &oneClient{cc}
}

func (c *oneClient) Magic(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/mattmoor.One/Magic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OneServer is the server API for One service.
type OneServer interface {
	Magic(context.Context, *Request) (*Response, error)
}

// UnimplementedOneServer can be embedded to have forward compatible implementations.
type UnimplementedOneServer struct {
}

func (*UnimplementedOneServer) Magic(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Magic not implemented")
}

func RegisterOneServer(s *grpc.Server, srv OneServer) {
	s.RegisterService(&_One_serviceDesc, srv)
}

func _One_Magic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OneServer).Magic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mattmoor.One/Magic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OneServer).Magic(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _One_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mattmoor.One",
	HandlerType: (*OneServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Magic",
			Handler:    _One_Magic_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// TwoClient is the client API for Two service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TwoClient interface {
	Blur(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	Blah(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type twoClient struct {
	cc *grpc.ClientConn
}

func NewTwoClient(cc *grpc.ClientConn) TwoClient {
	return &twoClient{cc}
}

func (c *twoClient) Blur(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/mattmoor.Two/Blur", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *twoClient) Blah(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/mattmoor.Two/Blah", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TwoServer is the server API for Two service.
type TwoServer interface {
	Blur(context.Context, *Request) (*Response, error)
	Blah(context.Context, *Request) (*Response, error)
}

// UnimplementedTwoServer can be embedded to have forward compatible implementations.
type UnimplementedTwoServer struct {
}

func (*UnimplementedTwoServer) Blur(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Blur not implemented")
}
func (*UnimplementedTwoServer) Blah(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Blah not implemented")
}

func RegisterTwoServer(s *grpc.Server, srv TwoServer) {
	s.RegisterService(&_Two_serviceDesc, srv)
}

func _Two_Blur_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoServer).Blur(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mattmoor.Two/Blur",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoServer).Blur(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Two_Blah_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TwoServer).Blah(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mattmoor.Two/Blah",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TwoServer).Blah(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Two_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mattmoor.Two",
	HandlerType: (*TwoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Blur",
			Handler:    _Two_Blur_Handler,
		},
		{
			MethodName: "Blah",
			Handler:    _Two_Blah_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}

// ThreeClient is the client API for Three service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ThreeClient interface {
	Foo(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	Bar(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	Baz(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type threeClient struct {
	cc *grpc.ClientConn
}

func NewThreeClient(cc *grpc.ClientConn) ThreeClient {
	return &threeClient{cc}
}

func (c *threeClient) Foo(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/mattmoor.Three/Foo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *threeClient) Bar(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/mattmoor.Three/Bar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *threeClient) Baz(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/mattmoor.Three/Baz", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ThreeServer is the server API for Three service.
type ThreeServer interface {
	Foo(context.Context, *Request) (*Response, error)
	Bar(context.Context, *Request) (*Response, error)
	Baz(context.Context, *Request) (*Response, error)
}

// UnimplementedThreeServer can be embedded to have forward compatible implementations.
type UnimplementedThreeServer struct {
}

func (*UnimplementedThreeServer) Foo(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Foo not implemented")
}
func (*UnimplementedThreeServer) Bar(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Bar not implemented")
}
func (*UnimplementedThreeServer) Baz(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Baz not implemented")
}

func RegisterThreeServer(s *grpc.Server, srv ThreeServer) {
	s.RegisterService(&_Three_serviceDesc, srv)
}

func _Three_Foo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThreeServer).Foo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mattmoor.Three/Foo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThreeServer).Foo(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Three_Bar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThreeServer).Bar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mattmoor.Three/Bar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThreeServer).Bar(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _Three_Baz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThreeServer).Baz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mattmoor.Three/Baz",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThreeServer).Baz(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _Three_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mattmoor.Three",
	HandlerType: (*ThreeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Foo",
			Handler:    _Three_Foo_Handler,
		},
		{
			MethodName: "Bar",
			Handler:    _Three_Bar_Handler,
		},
		{
			MethodName: "Baz",
			Handler:    _Three_Baz_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
